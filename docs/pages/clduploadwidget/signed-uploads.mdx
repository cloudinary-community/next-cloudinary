import Head from 'next/head';
import { Tab, Tabs, Callout } from 'nextra-theme-docs';

import OgImage from '../../components/OgImage';
import CodeBlock from '../../components/CodeBlock';

<Head>
  <title>CldUploadWidget Signed Uploads - Next Cloudinary</title>
  <meta name="og:title" content="CldUploadWidget Signed Uploads - Next Cloudinary" />
  <meta name="og:url" content={`https://next.cloudinary.dev/clduploadwidget/signed-uploads`} />
</Head>

<OgImage
  title="CldUploadWidget Signed Uploads"
  twitterTitle="CldUploadWidget Signed Uploads"
/>

# Signing CldUploadWidget Uploads

Signing requests is an easy way to provide enhanced security for your file uploads. This helps
deter people from making unauthenticated uploads to your cloud.

## Configuring Signed Uploads

Setting up CldUploadWidget to sign uploads is as simple as passing an API endpoint as a prop:

<CodeBlock>
  ```jsx copy showLineNumbers
  import { CldUploadWidget } from 'next-cloudinary';

  <CldUploadWidget signatureEndpoint="<API Endpoint (ex: /api/sign-cloudinary-params)>">
    {({ open }) => {
      return (
        <button onClick={() => open()}>
          Upload an Image
        </button>
      );
    }}
  </CldUploadWidget>
  ```
</CodeBlock>

However, that API endpoint needs to return a specific shape in order to properly communicate
with the CldUpload Widget.

<Callout emoji="⚠️" type="error">
  **Security Warning:** The signature endpoint must be properly secured with authentication and authorization checks. Without proper security measures, anyone can upload files to your Cloudinary account, potentially leading to:
  
  - Unauthorized storage consumption and bandwidth costs
  - Malicious content hosting under your account
  - Account suspension or legal liability
  
  **Always implement authentication** before signing upload requests in production environments.
</Callout>

## API Endpoint to Sign Requests

When working in Next.js, we gain access to a server environment through both somewhat traditional means
and serverless functions.

This means, we can use the [Cloudinary Node SDK](https://cloudinary.com/documentation/node_integration)
in order to easily sign our requests.

To start off, install the Cloudinary Node SDK with:

```shell
npm install cloudinary
```

In order to sign our requests, we'll need to use our Cloudinary API Key and Secret, so set additional
environment variables:

```
NEXT_PUBLIC_CLOUDINARY_API_KEY="<Your API Key>"
CLOUDINARY_API_SECRET="<Your API Secret>"
``` 

Then, we want to create a new API endpoint, which differs based on whether or not you're using
the App Router or Pages router.

<Tabs items={['App Router', 'Pages Router']}>
  <Tab>
    **In the App Router**, create a new API route file such as `app/api/sign-cloudinary-params/route.ts`, where
    inside, add the folowing code.

    <Callout emoji={false} type="warning">
      The following example includes basic security measures. **You must add authentication** (session verification, JWT validation, API key check, etc.) before deploying to production.
    </Callout>

    <CodeBlock>
      ```jsx copy showLineNumbers
      import { v2 as cloudinary } from "cloudinary";

      cloudinary.config({
        cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,
        api_key: process.env.CLOUDINARY_API_KEY,
        api_secret: process.env.CLOUDINARY_API_SECRET,
      });

      export async function POST(request: Request) {
        // TODO: Add authentication check here
        // Example: Verify user session, JWT token, or API key
        // const session = await getServerSession(authOptions);
        // if (!session || !session.user) {
        //   return Response.json({ error: 'Unauthorized' }, { status: 401 });
        // }

        const body = await request.json();
        const { paramsToSign } = body;

        // Validate input
        if (!paramsToSign || typeof paramsToSign !== 'object') {
          return Response.json({ error: 'Invalid parameters' }, { status: 400 });
        }

        try {
          const signature = cloudinary.utils.api_sign_request(
            paramsToSign, 
            process.env.CLOUDINARY_API_SECRET
          );
          
          return Response.json({ signature });
        } catch (error) {
          console.error('Cloudinary signature error:', error);
          return Response.json(
            { error: 'Failed to generate upload signature' }, 
            { status: 500 }
          );
        }
      }
      ```
    </CodeBlock>
  </Tab>
  <Tab>
    **In the Pages Router**, create a new API endpoint file such as `pages/api/sign-cloudinary-params.js`, where
    inside, add the folowing code:

    <Callout emoji={false} type="warning">
      If using Next Cloudinary v5 or lower, you need to use `JSON.parse(req.body)` to obtain the JSON payload
      of the Signature Request from the Upload Widget.
    </Callout>

    <Callout emoji={false} type="warning">
      The following example includes basic security measures. **You must add authentication** (session verification, JWT validation, API key check, etc.) before deploying to production.
    </Callout>

    <CodeBlock>
      ```jsx copy showLineNumbers
      import { v2 as cloudinary } from "cloudinary";

      cloudinary.config({
        cloud_name: process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,
        api_key: process.env.CLOUDINARY_API_KEY,
        api_secret: process.env.CLOUDINARY_API_SECRET,
      });

      export default async function handler(req, res) {
        // Validate HTTP method
        if (req.method !== 'POST') {
          return res.status(405).json({ error: 'Method not allowed' });
        }

        // TODO: Add authentication check here
        // Example: Verify user session, JWT token, or API key
        // const session = await getSession(req);
        // if (!session || !session.user) {
        //   return res.status(401).json({ error: 'Unauthorized' });
        // }

        const { paramsToSign } = req.body;

        // Validate input
        if (!paramsToSign || typeof paramsToSign !== 'object') {
          return res.status(400).json({ error: 'Invalid parameters' });
        }

        try {
          const signature = cloudinary.utils.api_sign_request(
            paramsToSign, 
            process.env.CLOUDINARY_API_SECRET
          );

          res.status(200).json({ signature });
        } catch (error) {
          console.error('Cloudinary signature error:', error);
          res.status(500).json({ 
            error: 'Failed to generate upload signature' 
          });
        }
      }
      ```
    </CodeBlock>

  </Tab>
</Tabs>